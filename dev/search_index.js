var documenterSearchIndex = {"docs":
[{"location":"#BranchingFlows","page":"Home","title":"BranchingFlows","text":"Documentation for BranchingFlows.\n\n","category":"section"},{"location":"#BranchingFlows.BalancedSequential","page":"Home","title":"BranchingFlows.BalancedSequential","text":"BalancedSequential(; alpha=1.0)\n\nSequential policy that prefers coalescing smaller adjacent clusters first, encouraging balanced trees while respecting sequence adjacency. For an eligible adjacent pair (i,i+1), the sampling weight is (w_i + w_{i+1})^(-alpha) where w_k = nodes[k].weight. Set alpha=0 to recover uniform sequential selection; larger alpha increases preference for smaller clusters.\n\n\n\n\n\n","category":"type"},{"location":"#BranchingFlows.BranchingState","page":"Home","title":"BranchingFlows.BranchingState","text":"BranchingState(state, groupings)\n\nHolds a batched state (or tuple of states) together with a matrix of group IDs (groupings::AbstractMatrix{<:Integer}) with shape (L, b), where L is the sequence length and b is batch size. Elements only coalesce/split within the same group.\n\nFields:\n\nstate: a MaskedState or a tuple of MaskedStates representing the element-wise process state(s) at the current time.\ngroupings::AbstractMatrix{<:Integer}: per-position group id.\ndel::AbstractMatrix{Bool}: marks indices corresponding to to-be-deleted leaves in the conditional path.\nids::AbstractMatrix{Int}: element ids for tracking; merged internal nodes produced during forest construction use id 0.\nbranchmask::AbstractMatrix{Bool}: where true, splits/deletions are permitted; where false, they are suppressed.\nflowmask::AbstractMatrix{Bool}: where true, the base process updates via Flowfusion.step; where false, state is held fixed.\npadmask::AbstractMatrix{Bool}: marks valid (unpadded) positions.\n\nConvenience constructor:     BranchingState(state, groupings; del=zeros(Bool,...), ids=1:size(groupings,1),                    branchmask=ones(Bool,...), flowmask=ones(Bool,...),                    padmask=ones(Bool,...))\n\n\n\n\n\n","category":"type"},{"location":"#BranchingFlows.CoalescencePolicy","page":"Home","title":"BranchingFlows.CoalescencePolicy","text":"Abstract supertype for all coalescence selection policies.\n\nImplementors should provide:\n\nselect_coalescence(policy, nodes) => Union{Nothing,Tuple{Int,Int}}\nmax_coalescences(policy, nodes) => Int\n\nOptional stateful hooks (no-ops by default):\n\ninit!(policy, nodes)\nupdate!(policy, nodes, i, j, new_index)\n\n\n\n\n\n","category":"type"},{"location":"#BranchingFlows.CoalescentFlow","page":"Home","title":"BranchingFlows.CoalescentFlow","text":"CoalescentFlow{Proc,D,F,Pol,Delp,Dh} <: Process\n\nBranching/coalescent flow wrapper that composes an underlying Flowfusion process P with stochastic coalescence (backward) / splitting (forward) events, and optional deletions governed by a time-hazard distribution.\n\nFields:\n\nP::Proc: underlying Flowfusion process (or tuple of processes) used for bridging between coalescence times.\nbranch_time_dist::D: distribution on [0, 1] controlling split/coalescence event timing. Used both to sample absolute split times (for forests) and to scale small-step split Poisson rates via a truncated pdf at the current time.\nsplit_transform::F: elementwise map that converts model-predicted event logits into nonnegative intensities for split counts during forward-time simulation (default: x -> exp.(clamp.(x, -100, 11))).\ncoalescence_policy::Pol: policy controlling which elements coalesce at each event; see policies in merging.jl.\ndeletion_policy::Delp: tag for deletion behavior (placeholder hook).\ndeletion_time_dist::Dh: distribution on [0, 1] specifying the deletion hazard via its pdf/cdf; used exactly over intervals during conditional path sampling and via a small-step hazard approximation during step.\n\nConstructors:\n\nCoalescentFlow(P, branch_time_dist) uses the default split_transform, SequentialUniform() policy, and Uniform(0, 1) deletion-time distribution.\nCoalescentFlow(P, branch_time_dist, policy) as above with a custom policy.\nCoalescentFlow(P, branch_time_dist, policy, deletion_time_dist) as above with a custom deletion-time distribution.\n\nNotes:\n\nSequential policies assume sequence order is meaningful. Coalescences/splits are further constrained within groups (see BranchingState.groupings).\n\n\n\n\n\n","category":"type"},{"location":"#BranchingFlows.SequentialCoalescencePolicy","page":"Home","title":"BranchingFlows.SequentialCoalescencePolicy","text":"Coalescence policies merge sequentially adjacent elements, and thus depend on the sequential ordering of nodes.\n\nModels using SequentialCoalescencePolicy may exploit sequence-order features (e.g., positional encodings). Caller must ensure ordering is meaningful. If the model does not have sequence-order features, then a SequentialCoalescencePolicy may still make sense if sequential order happens to relate to some other proximity property, otherwise it is just a weird kind of random coalescence.\n\n\n\n\n\n","category":"type"},{"location":"#BranchingFlows.all_intragroup_pairs-Tuple{Any}","page":"Home","title":"BranchingFlows.all_intragroup_pairs","text":"all_intragroup_pairs(nodes)\n\nIterator over all eligible intragroup pairs (i, j) with i<j.\n\n\n\n\n\n","category":"method"},{"location":"#BranchingFlows.branching_bridge-Tuple{CoalescentFlow, Any, Any, Any}","page":"Home","title":"BranchingFlows.branching_bridge","text":"branching_bridge(P::CoalescentFlow, X0sampler, X1s, times;\n                 T=Float32, use_branching_time_prob=0, maxlen=Inf,\n                 coalescence_factor=1.0, merger=canonical_anchor_merge,\n                 coalescence_policy=P.coalescence_policy,\n                 length_mins=nothing, deletion_pad=0, X1_modifier=identity)\n\nVectorized conditional bridging over a batch. For each (X1, t) pair, samples an independent forest (respecting group minima and policy), runs tree_bridge for all roots and aggregates the outputs into batched tensors.\n\nArguments:\n\ntimes: vector of times (length = batch size) or a UnivariateDistribution (a time is drawn per batch item).\nlength_mins: per-group minima control for forest construction. May be: nothing, Int, DiscreteUnivariateDistribution, Dict{Int,Int}, Dict{Int,<:DiscreteUnivariateDistribution}, or a vector of any of these (length equal to batch size).\ndeletion_pad: if > 0, pads each X1 with additional to-be-deleted duplicates so that, in expectation, each group has deletion_pad * max(len(x0_group), len(x1_group)) elements; implemented via per-group Poisson draws and group_fixedcount_del_insertions.\nX1_modifier: optional transform applied to each (possibly deletion-padded) X1 prior to forest sampling (e.g., to enforce masking on deleted states).\n\nReturns a named tuple:\n\nt::Vector{T}: the time used per batch item (possibly overridden by a split time).\nXt::BranchingState: batched states at time t, with state as masked states (or tuple thereof) and bookkeeping masks/ids/groupings.\nX1anchor: masked anchor states batched in the same structure as Xt.state.\ndel::Matrix{Bool}: deletion flags per element in Xt.\ndescendants::Matrix{Int}: descendant counts (w) per element.\nsplits_target::Matrix{T}: per-element training targets for split heads, computed as max(descendants-1, 0).\nprev_coalescence::Matrix{T}: last coalescence time before each element.\n\n\n\n\n\n","category":"method"},{"location":"#BranchingFlows.canonical_anchor_merge-Tuple{Tuple{Vararg{Union{ForwardBackward.State, Flowfusion.Guide, Flowfusion.MaskedState}}}, Tuple{Vararg{Union{ForwardBackward.State, Flowfusion.Guide, Flowfusion.MaskedState}}}, Any, Any}","page":"Home","title":"BranchingFlows.canonical_anchor_merge","text":"canonical_anchor_merge(S1, S2, w1, w2)\n\nMerge two anchor states S1 and S2 (each possibly a tuple of component states) into a single anchor representing their parent during tree coalescence.\n\nBehavior by component:\n\nTuple of states: applies canonical_anchor_merge elementwise with the same weights.\nMaskedState: unwraps and merges the underlying state.\nContinuousState: weighted Euclidean average, (w1*S1 + w2*S2)/(w1+w2).\nManifoldState: geodesic interpolation via ForwardBackward.interpolate(S1, S2, w2, w1).\nDiscreteState: sets the anchor to the mask/dummy token (assumes the dummy token is the last category K); both dense-int and onehot encodings are supported.\n\nw1 and w2 are nonnegative weights, typically child descendant counts, used only by the continuous/manifold components; discrete components always resolve to the dummy token to avoid leaking label information through anchors.\n\n\n\n\n\n","category":"method"},{"location":"#BranchingFlows.fixedcount_del_insertions-Tuple{BranchingState, Any}","page":"Home","title":"BranchingFlows.fixedcount_del_insertions","text":"fixedcount_del_insertions(X1::BranchingState, num_events)\n\nInsert exactly num_events duplication events into X1, sampling targets uniformly with replacement from elements where flowmask & branchmask are true. Each event inserts a duplicate either before or after the original (chosen uniformly at random). For each event, exactly one of the two involved indices (original or the newly inserted duplicate) is marked for deletion. If multiple events hit the same original, only one can mark the original as deleted; subsequent events allocate their deletion to their respective duplicates.\n\nReturns a new BranchingState constructed analogously to uniform_del_insertions.\n\n\n\n\n\n","category":"method"},{"location":"#BranchingFlows.forest_bridge-Tuple{CoalescentFlow, Vararg{Any, 7}}","page":"Home","title":"BranchingFlows.forest_bridge","text":"forest_bridge(P::CoalescentFlow, X0sampler, X1, t, groups, branchable, flowable, deleted;\n              T=Float32, use_branching_time_prob=0, maxlen=Inf,\n              coalescence_factor=1.0, merger=canonical_anchor_merge,\n              coalescence_policy=P.coalescence_policy, group_mins=nothing)\n\nRun a single conditional bridge at time t for each root in a forest sampled from X1 and groups. The forest is built with sample_forest using the provided branchable, flowable, and deleted flags. Returns a flat vector of segment tuples (see tree_bridge).\n\nArguments:\n\nX0sampler(root): a function that, given a forest root node, returns the initial state to bridge from.\nuse_branching_time_prob: with this probability, override t with a random absolute split time drawn from the forest’s coal_times, exposing the model to states exactly at split points.\nmaxlen: if the number of segments at/after t would exceed maxlen, this function resamples the forest to keep the total bounded.\ngroup_mins: forwarded through to sample_forest (see its docstring).\n\n\n\n\n\n","category":"method"},{"location":"#BranchingFlows.group_fixedcount_del_insertions-Tuple{BranchingState, Any}","page":"Home","title":"BranchingFlows.group_fixedcount_del_insertions","text":"group_fixedcount_del_insertions(X1::BranchingState, group_num_events)\n\nInsert a fixed number of duplication events per group as specified by the dictionary group_num_events, which maps a group index (as found in X1.groupings) to the number of events for that group.\n\nBehavior per event matches fixedcount_del_insertions:\n\nTarget indices are sampled uniformly with replacement among elements where flowmask & branchmask are true and whose group equals the requested group.\nEach event inserts a duplicate either before or after the original (chosen uniformly at random).\nFor each event, exactly one of the two involved indices (original or newly inserted duplicate) is marked for deletion. If multiple events hit the same original, only one can mark the original as deleted; subsequent events allocate their deletion to their respective duplicates.\n\nReturns a new BranchingState constructed analogously to uniform_del_insertions.\n\n\n\n\n\n","category":"method"},{"location":"#BranchingFlows.groupwise_max_coalescences-Tuple{Any}","page":"Home","title":"BranchingFlows.groupwise_max_coalescences","text":"Compute an upper bound on the number of coalescences possible under branchable merging within groups. Used as a default for non-sequential policies.\n\n\n\n\n\n","category":"method"},{"location":"#BranchingFlows.max_coalescences-Tuple{SequentialUniform, Any}","page":"Home","title":"BranchingFlows.max_coalescences","text":"max_coalescences(::SequentialUniform, nodes)\n\nCount the number of eligible sequentially-adjacent pairs.\n\n\n\n\n\n","category":"method"},{"location":"#BranchingFlows.next_split_time-Union{Tuple{T}, Tuple{Any, Any, T}} where T","page":"Home","title":"BranchingFlows.next_split_time","text":"Absolute time of the next split on this lineage.\n\nH  : distribution for F_H on [0,1] with cdf and quantile W  : descendant count at the next node, m = W - 1 must be ≥ 1 t0 : current absolute time in [0,1)\n\nImplements: draw E ~ Exp(1), set S* = (1 - cdf(H,t0)) * exp(-E/m), return quantile(H, 1 - S*).\n\n\n\n\n\n","category":"method"},{"location":"#BranchingFlows.sample_forest-Tuple{CoalescentFlow, AbstractVector}","page":"Home","title":"BranchingFlows.sample_forest","text":"sample_forest(P::CoalescentFlow, elements;\n              groupings=zeros(Int, length(elements)),\n              branchable=ones(Bool, length(elements)),\n              flowable=ones(Bool, length(elements)),\n              deleted=zeros(Bool, length(elements)),\n              ids=1:length(elements),\n              T=Float32,\n              coalescence_factor=1.0,\n              merger=canonical_anchor_merge,\n              coalescence_policy=P.coalescence_policy,\n              group_mins=nothing)\n\nSample a coalescent forest over elements with per-element groupings and boolean branchable flags. Returns (forest_nodes, coal_times) where forest_nodes is a vector of FlowNode roots (one per surviving group block), and coal_times is a vector of absolute split times sampled across the forest (not sorted).\n\nArguments:\n\nflowable: marks elements whose state should be bridged (non-flowables are emitted as fixed segments during conditional path sampling).\ndeleted: marks which leaves correspond to to-be-deleted elements at t=1.\nids: element ids to carry through the forest (merged internal nodes get id 0; merged nodes are always flowable and never deleted).\ncoalescence_factor: Binomial parameter scaling the maximum possible number of coalescences computed by the policy. May be a numeric in [0,1] or a UnivariateDistribution (sampled once per call). 1.0 collapses each group to one root; 0.0 yields no coalescences.\nmerger: function merger(left_state, right_state, w_left, w_right) used to build anchor states for internal nodes; see canonical_anchor_merge and select_anchor_merge.\ncoalescence_policy: chooses which pair to coalesce at each event; see merging.jl for available policies and their semantics.\ngroup_mins: forwarded to select_coalescence. Supported forms depend on the active policy. For SequentialUniform, supported values are: nothing (no per-group minimum), Dict{Int,Int} (fixed per-group minima), or Int (uniform minimum for contiguous branchable blocks per group).\n\n\n\n\n\n","category":"method"},{"location":"#BranchingFlows.sample_split_times!-Union{Tuple{T}, Tuple{CoalescentFlow, BranchingFlows.FlowNode, T}} where T","page":"Home","title":"BranchingFlows.sample_split_times!","text":"sample_split_times!(P::CoalescentFlow, node::FlowNode, t0; collection=nothing)\n\nAssign absolute split times to all internal nodes in the subtree rooted at node using next_split_time(P.branch_time_dist, node.weight, t0) whenever node.weight > 1. Recurses into children with the newly assigned time as the lower bound.\n\nIf collection is provided (a vector), pushes each sampled absolute time into it. The collected times are not sorted.\n\n\n\n\n\n","category":"method"},{"location":"#BranchingFlows.select_anchor_merge-NTuple{4, Any}","page":"Home","title":"BranchingFlows.select_anchor_merge","text":"select_anchor_merge(S1, S2, w1, w2)\n\nStochastic alternative to canonical_anchor_merge that selects one of the two children as the parent anchor without interpolation. Chooses S1 with probability w1/(w1+w2) and S2 otherwise, then calls canonical_anchor_merge with weights (1,0) or (0,1) to preserve type-specific behavior (e.g., discrete masking).\n\nIntended for scenarios where copying a child is preferable to averaging (e.g., to keep anchors on-manifold for complex discrete/structured components).\n\n\n\n\n\n","category":"method"},{"location":"#BranchingFlows.select_coalescence-Tuple{SequentialUniform, Any, Nothing}","page":"Home","title":"BranchingFlows.select_coalescence","text":"select_coalescence(::SequentialUniform, nodes)\n\nUniformly choose one sequentially-adjacent branchable pair (i, i+1) within the same group. Returns nothing if no such pair exists.\n\n\n\n\n\n","category":"method"},{"location":"#BranchingFlows.sequential_pairs-Tuple{Any}","page":"Home","title":"BranchingFlows.sequential_pairs","text":"sequential_pairs(nodes)\n\nIterator over all sequentially-adjacent eligible pairs (i, i+1) within groups.\n\n\n\n\n\n","category":"method"},{"location":"#BranchingFlows.should_append_on_split-Tuple{BranchingFlows.CoalescencePolicy}","page":"Home","title":"BranchingFlows.should_append_on_split","text":"should_append_on_split(policy::CoalescencePolicy) -> Bool\n\nIndicates whether forward-time split insertions should be appended to the end of the sequence (true), or inserted adjacently at the split location (false). Defaults to false.\n\n\n\n\n\n","category":"method"},{"location":"#BranchingFlows.tree_bridge-Tuple{CoalescentFlow, Vararg{Any, 5}}","page":"Home","title":"BranchingFlows.tree_bridge","text":"tree_bridge(P::CoalescentFlow, node, Xs, target_t, current_t, collection)\n\nRecursively traverse a FlowNode tree, running the underlying bridge bridge(P.P, Xs, node.node_data, current_t, next_t) either up to target_t or the node’s own split time. For each branch that crosses target_t, appends to collection a named tuple with fields:\n\nXt: the bridged state at target_t (or the node’s anchor if non-flowable),\nt: the evaluation time used for this segment,\nX1anchor: the anchor (node_data) ahead of the segment,\ndescendants: the node’s descendant count (weight),\ndel: whether this branch terminates in deletion at t=1,\nbranchable: whether splits are permitted on this segment,\nflowable: whether the base process should evolve this segment,\ngroup: group id,\nlast_coalescence: the most recent coalescence/split time behind the segment (open interval start),\nid: element id carried from the leaf; internal nodes use 0.\n\nDeletion handling:\n\nDuring conditional path sampling, deletions use the exact survival ratio over [current_t, target_t] induced by P.deletion_time_dist (i.e., survival S(t)/S(currentt)), removing segments that fail to survive to `targett`.\n\n\n\n\n\n","category":"method"},{"location":"#Flowfusion.regroup-Tuple{AbstractVector{<:Tuple}}","page":"Home","title":"Flowfusion.regroup","text":"Flowfusion.regroup(elarray::AbstractVector{<:Tuple})\n\nUtility to batch a vector of element-wise tuples of states into a tuple of batched states. Given elarray::Vector{Tuple{S₁, S₂, …, Sₖ}} of length L, returns Tuple{Ŝ₁, Ŝ₂, …, Ŝₖ} where each Ŝᵢ has length L (stacking the elements along the sequence dimension).\n\nThis specialization enables:\n\nMaskedState.(regroup(elements), (flowmask,), (padmask,))\n\nwhen building BranchingState batches from per-segment bridges.\n\n\n\n\n\n","category":"method"},{"location":"#Flowfusion.step-Tuple{CoalescentFlow, BranchingState, Tuple, Real, Real}","page":"Home","title":"Flowfusion.step","text":"Flowfusion.step(P::CoalescentFlow, XₜBS::BranchingState, hat::Tuple, s₁::Real, s₂::Real)\n\nAdvance the process forward in time from s₁ to s₂ for a single-batch BranchingState, allowing split events. The underlying continuous/discrete states are advanced via Flowfusion.step(P.P, ...), and split counts are drawn from a Poisson law parameterized by the transformed event intensities and a factor of the truncated branch-time density at s₁.\n\nDeletion handling:\n\nUses a small-step hazard approximation induced by P.deletion_time_dist.\nLet h(s₁) = f(s₁) / S(s₁) where f/S are the pdf/survival. The base small-step probability is 1 - exp(-h(s₁) * Δt), scaled by ρ = sigmoid(del_logits) from the model head. Deletions are suppressed where branchmask is false.\n\nSplit handling:\n\nPer-position split counts are sampled from Poisson(Δt * split_transform(λ) * pdf(Truncated(branch_time_dist, s₁, 1), s₁)), masked by branchmask.\nIf a discrete component changes its token at an index between s₁ and s₂, splits at that index are suppressed for this step to avoid simultaneous discrete changes and splits.\nNew elements are inserted adjacently after the split location (no append mode).\n\nReturns a new single-batch BranchingState where:\n\nstate holds the updated masked states,\ngroupings, flowmask, branchmask are updated to reflect splits/deletions,\ndefault ids, padmask, and del are constructed consistently with shapes.\n\n\n\n\n\n","category":"method"}]
}
