var documenterSearchIndex = {"docs":
[{"location":"#BranchingFlows","page":"Home","title":"BranchingFlows","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for BranchingFlows.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#BranchingFlows.BalancedSequential","page":"Home","title":"BranchingFlows.BalancedSequential","text":"BalancedSequential(; alpha=1.0)\n\nSequential policy that prefers coalescing smaller adjacent clusters first, encouraging balanced trees while respecting sequence adjacency. For an eligible adjacent pair (i,i+1), the sampling weight is (w_i + w_{i+1})^(-alpha) where w_k = nodes[k].weight. Set alpha=0 to recover uniform sequential selection; larger alpha increases preference for smaller clusters.\n\n\n\n\n\n","category":"type"},{"location":"#BranchingFlows.BranchingState","page":"Home","title":"BranchingFlows.BranchingState","text":"BranchingState(state, groupings)\n\nHolds a batched state (or tuple of states) together with a matrix of group IDs (groupings::AbstractMatrix{<:Integer}) with shape (L, b), where L is sequence length and b is batch size. Elements only coalesce within the same group.\n\n\n\n\n\n","category":"type"},{"location":"#BranchingFlows.CoalescencePolicy","page":"Home","title":"BranchingFlows.CoalescencePolicy","text":"Abstract supertype for all coalescence selection policies.\n\nImplementors should provide:\n\nselect_coalescence(policy, nodes) => Union{Nothing,Tuple{Int,Int}}\nmax_coalescences(policy, nodes) => Int\n\nOptional stateful hooks (no-ops by default):\n\ninit!(policy, nodes)\nupdate!(policy, nodes, i, j, new_index)\n\n\n\n\n\n","category":"type"},{"location":"#BranchingFlows.CoalescentFlow","page":"Home","title":"BranchingFlows.CoalescentFlow","text":"CoalescentFlow{Proc,D,F,Pol}\n\nBranching/coalescent flow wrapper that augments an underlying state-space process P with stochastic coalescence/splitting events.\n\nFields:\n\nP::Proc: underlying Flowfusion process (or tuple of processes) used for bridging between coalescence times.\nbranch_time_dist::D: distribution over coalescence times in (0, 1], used to sample event times (sorted descending, because coalescence walks backward).\nsplit_transform::F: elementwise map that converts model-predicted event logits into nonnegative intensities for split counts during forward-time simulation.\ncoalescence_policy::Pol: policy controlling which elements coalesce at each event; see policies in merging.jl.\n\nConstructors:\n\nCoalescentFlow(P, branch_time_dist) uses exp(clamp(x, -100, 11)) as split_transform and SequentialUniform() as policy.\nCoalescentFlow(P, branch_time_dist, policy) uses the same default split_transform, but sets the provided policy.\n\nNotes:\n\nSequential policies assume the sequence order is meaningful. Non-sequential policies assume the model is invariant to sequence permutations.\n\n\n\n\n\n","category":"type"},{"location":"#BranchingFlows.SequentialCoalescencePolicy","page":"Home","title":"BranchingFlows.SequentialCoalescencePolicy","text":"Coalescence policies merge sequentially adjacent elements, and thus depend on the sequential ordering of nodes.\n\nModels using SequentialCoalescencePolicy may exploit sequence-order features (e.g., positional encodings). Caller must ensure ordering is meaningful. If the model does not have sequence-order features, then a SequentialCoalescencePolicy may still make sense if sequential order happens to relate to some other proximity property, otherwise it is just a weird kind of random coalescence.\n\n\n\n\n\n","category":"type"},{"location":"#BranchingFlows.all_intragroup_pairs-Tuple{Any}","page":"Home","title":"BranchingFlows.all_intragroup_pairs","text":"all_intragroup_pairs(nodes)\n\nIterator over all eligible intragroup pairs (i, j) with i<j.\n\n\n\n\n\n","category":"method"},{"location":"#BranchingFlows.branching_bridge-Tuple{CoalescentFlow, Any, Any, Any}","page":"Home","title":"BranchingFlows.branching_bridge","text":"branching_bridge(P::CoalescentFlow, X0sampler, X1s, times;\n                 maxlen=Inf, coalescence_factor=1.0,\n                 merger=canonical_anchor_merge,\n                 coalescence_policy=P.coalescence_policy)\n\nVectorized bridge over a batch of inputs. For each (X1, t) pair, samples a forest (per coalescence_policy), runs tree_bridge and aggregates outputs into batched MaskedStates plus bookkeeping. use_branching_time_prob lets you use an actual coalescence time as the bridge time, which allows the model to see states right at the split point, which will be the case during inference.\n\nReturns a named tuple with fields:\n\nt: the times provided\nXt: BranchingState of the bridged states (masked)\nX1anchor: BranchingState of anchors matched to each Xt\ndescendants: counts per segment\nsplits_target: target split intensities for training heads\nbranchmask, padmask, prev_coalescence: masks and last event time\n\nExample:\n\nP = CoalescentFlow(BrownianMotion(), Uniform(0.0f0, 1.0f0), last_to_nearest_coalescence(state_index=1))\nout = branching_bridge(P, X0sampler, X1s, times; coalescence_factor=0.8)\n\n\n\n\n\n","category":"method"},{"location":"#BranchingFlows.canonical_anchor_merge-Tuple{Tuple{Vararg{Union{ForwardBackward.State, Flowfusion.Guide, Flowfusion.MaskedState}}}, Tuple{Vararg{Union{ForwardBackward.State, Flowfusion.Guide, Flowfusion.MaskedState}}}, Any, Any}","page":"Home","title":"BranchingFlows.canonical_anchor_merge","text":"canonical_anchor_merge(S1, S2, w1, w2)\n\nMerge two anchor states S1 and S2 (each possibly a tuple of component states) into a single anchor representing their parent during tree coalescence.\n\nBehavior by component:\n\nTuple of states: applies canonical_anchor_merge elementwise with the same weights.\nMaskedState: unwraps and merges the underlying state.\nContinuousState: weighted Euclidean average, (w1*S1 + w2*S2)/(w1+w2).\nManifoldState: geodesic interpolation via ForwardBackward.interpolate(S1, S2, w2, w1).\nDiscreteState: sets the anchor to the mask/dummy token (assumes the dummy token is the last category K); both dense-int and onehot encodings are supported.\n\nw1 and w2 are nonnegative weights, typically child descendant counts, used only by the continuous/manifold components; discrete components always resolve to the dummy token to avoid leaking label information through anchors.\n\n\n\n\n\n","category":"method"},{"location":"#BranchingFlows.fixedcount_del_insertions-Tuple{BranchingState, Any}","page":"Home","title":"BranchingFlows.fixedcount_del_insertions","text":"fixedcount_del_insertions(X1::BranchingState, num_events)\n\nInsert exactly num_events duplication events into X1, sampling targets uniformly with replacement from elements where flowmask & branchmask are true. Each event inserts a duplicate either before or after the original (chosen uniformly at random). For each event, exactly one of the two involved indices (original or the newly inserted duplicate) is marked for deletion. If multiple events hit the same original, only one can mark the original as deleted; subsequent events allocate their deletion to their respective duplicates.\n\nReturns a new BranchingState constructed analogously to uniform_del_insertions.\n\n\n\n\n\n","category":"method"},{"location":"#BranchingFlows.forest_bridge-Tuple{CoalescentFlow, Vararg{Any, 7}}","page":"Home","title":"BranchingFlows.forest_bridge","text":"forest_bridge(P::CoalescentFlow, X0sampler, X1, t, groups, branchable;\n              maxlen=Inf, coalescence_factor=1.0,\n              merger=canonical_anchor_merge,\n              coalescence_policy=P.coalescence_policy)\n\nRun a single bridge at time t for each tree in the sampled forest built from X1 and groups. Returns a flat vector of segment tuples (see tree_bridge).\n\nNotes:\n\nIf the sampled forest plus early-time branches would exceed maxlen, the function resamples to keep the total length bounded.\n\n\n\n\n\n","category":"method"},{"location":"#BranchingFlows.group_fixedcount_del_insertions-Tuple{BranchingState, Any}","page":"Home","title":"BranchingFlows.group_fixedcount_del_insertions","text":"group_fixedcount_del_insertions(X1::BranchingState, group_num_events)\n\nInsert a fixed number of duplication events per group as specified by the dictionary group_num_events, which maps a group index (as found in X1.groupings) to the number of events for that group.\n\nBehavior per event matches fixedcount_del_insertions:\n\nTarget indices are sampled uniformly with replacement among elements where flowmask & branchmask are true and whose group equals the requested group.\nEach event inserts a duplicate either before or after the original (chosen uniformly at random).\nFor each event, exactly one of the two involved indices (original or newly inserted duplicate) is marked for deletion. If multiple events hit the same original, only one can mark the original as deleted; subsequent events allocate their deletion to their respective duplicates.\n\nReturns a new BranchingState constructed analogously to uniform_del_insertions.\n\n\n\n\n\n","category":"method"},{"location":"#BranchingFlows.groupwise_max_coalescences-Tuple{Any}","page":"Home","title":"BranchingFlows.groupwise_max_coalescences","text":"Compute an upper bound on the number of coalescences possible under branchable merging within groups. Used as a default for non-sequential policies.\n\n\n\n\n\n","category":"method"},{"location":"#BranchingFlows.max_coalescences-Tuple{SequentialUniform, Any}","page":"Home","title":"BranchingFlows.max_coalescences","text":"max_coalescences(::SequentialUniform, nodes)\n\nCount the number of eligible sequentially-adjacent pairs.\n\n\n\n\n\n","category":"method"},{"location":"#BranchingFlows.next_split_time-Union{Tuple{T}, Tuple{Any, Any, T}} where T","page":"Home","title":"BranchingFlows.next_split_time","text":"Absolute time of the next split on this lineage.\n\nH  : distribution for F_H on [0,1] with cdf and quantile W  : descendant count at the next node, m = W - 1 must be ≥ 1 t0 : current absolute time in [0,1)\n\nImplements: draw E ~ Exp(1), set S* = (1 - cdf(H,t0)) * exp(-E/m), return quantile(H, 1 - S*).\n\n\n\n\n\n","category":"method"},{"location":"#BranchingFlows.sample_forest-Tuple{CoalescentFlow, AbstractVector}","page":"Home","title":"BranchingFlows.sample_forest","text":"sample_forest(P::CoalescentFlow, elements; groupings, branchable, T=Float32,\n              coalescence_factor=1.0, merger=canonical_anchor_merge,\n              coalescence_policy=P.coalescence_policy)\n\nSample a coalescent forest over elements with per-element groupings and boolean branchable flags. Returns (forest_nodes, coal_times) where forest_nodes is a vector of FlowNode roots (one per surviving group block) and coal_times are the sampled coalescence times (descending).\n\nArguments:\n\ncoalescence_factor: Binomial parameter that scales the maximum number of possible coalescences under the policy; 1.0 tends to collapse each group to one element, 0.0 produces no coalescences.\nmerger: function used to build anchor states when two nodes coalesce.\ncoalescence_policy: chooses which pair to coalesce at each event; defaults to P.coalescence_policy.\ngroup_mins: either nothing, or a dictionary that maps group indices to minimum sizes.\n\nIf provided, will not allow any merges when there are fewer than this many elements for each group. Useful if you need specific size control over the X0 distribution so you know what to sample from.\n\n\n\n\n\n","category":"method"},{"location":"#BranchingFlows.select_anchor_merge-NTuple{4, Any}","page":"Home","title":"BranchingFlows.select_anchor_merge","text":"select_anchor_merge(S1, S2, w1, w2)\n\nStochastic alternative to canonical_anchor_merge that selects one of the two children as the parent anchor without interpolation. Chooses S1 with probability w1/(w1+w2) and S2 otherwise, then calls canonical_anchor_merge with weights (1,0) or (0,1) to preserve type-specific behavior (e.g., discrete masking).\n\nIntended for scenarios where copying a child is preferable to averaging (e.g., to keep anchors on-manifold for complex discrete/structured components).\n\n\n\n\n\n","category":"method"},{"location":"#BranchingFlows.select_coalescence-Tuple{SequentialUniform, Any, Nothing}","page":"Home","title":"BranchingFlows.select_coalescence","text":"select_coalescence(::SequentialUniform, nodes)\n\nUniformly choose one sequentially-adjacent branchable pair (i, i+1) within the same group. Returns nothing if no such pair exists.\n\n\n\n\n\n","category":"method"},{"location":"#BranchingFlows.sequential_pairs-Tuple{Any}","page":"Home","title":"BranchingFlows.sequential_pairs","text":"sequential_pairs(nodes)\n\nIterator over all sequentially-adjacent eligible pairs (i, i+1) within groups.\n\n\n\n\n\n","category":"method"},{"location":"#BranchingFlows.should_append_on_split-Tuple{BranchingFlows.CoalescencePolicy}","page":"Home","title":"BranchingFlows.should_append_on_split","text":"should_append_on_split(policy::CoalescencePolicy) -> Bool\n\nIndicates whether forward-time split insertions should be appended to the end of the sequence (true), or inserted adjacently at the split location (false). Defaults to false.\n\n\n\n\n\n","category":"method"},{"location":"#BranchingFlows.tree_bridge-Tuple{CoalescentFlow, Vararg{Any, 5}}","page":"Home","title":"BranchingFlows.tree_bridge","text":"tree_bridge(P::CoalescentFlow, node, Xs, target_t, current_t, collection)\n\nRecursively traverse a FlowNode tree, running the underlying bridge from current_t to target_t on branches that cross the target time. Appends a named tuple for each leaf-like segment to collection with fields: Xt, X1anchor, descendants, cmasked, group, last_coalescence.\n\n\n\n\n\n","category":"method"},{"location":"#Flowfusion.regroup-Tuple{AbstractVector{<:Tuple}}","page":"Home","title":"Flowfusion.regroup","text":"Flowfusion.regroup(elarray::AbstractVector{<:Tuple})\n\nUtility to batch a vector of element-wise tuples of states into a tuple of batched states. Given elarray::Vector{Tuple{S₁, S₂, …, Sₖ}} of length L, returns Tuple{Ŝ₁, Ŝ₂, …, Ŝₖ} where each Ŝᵢ has length L (stacking the elements along the sequence dimension).\n\nThis specialization enables:\n\nMaskedState.(regroup(elements), (flowmask,), (padmask,))\n\nwhen building BranchingState batches from per-segment bridges.\n\n\n\n\n\n","category":"method"},{"location":"#Flowfusion.step-Tuple{CoalescentFlow, BranchingState, Tuple, Real, Real}","page":"Home","title":"Flowfusion.step","text":"Flowfusion.step(P::CoalescentFlow, XₜBS::BranchingState, hat::Tuple, s₁::Real, s₂::Real)\n\nAdvance the process forward in time from s₁ to s₂ for a single-batch BranchingState, allowing split events. The underlying continuous/discrete states are advanced via Flowfusion.step(P.P, ...), and split counts are drawn from a Poisson law parameterized by the transformed event intensities and the truncated branch-time density at s₁.\n\nInsertion behavior on split is controlled by the coalescence policy trait should_append_on_split(P.coalescence_policy):\n\nIf false (default), new elements are inserted adjacently after the split location.\nIf true, new elements are appended to the end of their group block (not the entire sequence), preserving original element order.\n\nReturns a new BranchingState with updated states and groupings.\n\n\n\n\n\n","category":"method"}]
}
