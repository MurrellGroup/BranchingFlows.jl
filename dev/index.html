<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · BranchingFlows.jl</title><meta name="title" content="Home · BranchingFlows.jl"/><meta property="og:title" content="Home · BranchingFlows.jl"/><meta property="twitter:title" content="Home · BranchingFlows.jl"/><meta name="description" content="Documentation for BranchingFlows.jl."/><meta property="og:description" content="Documentation for BranchingFlows.jl."/><meta property="twitter:description" content="Documentation for BranchingFlows.jl."/><meta property="og:url" content="https://MurrellGroup.github.io/BranchingFlows.jl/"/><meta property="twitter:url" content="https://MurrellGroup.github.io/BranchingFlows.jl/"/><link rel="canonical" href="https://MurrellGroup.github.io/BranchingFlows.jl/"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>BranchingFlows.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/MurrellGroup/BranchingFlows.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/MurrellGroup/BranchingFlows.jl/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="BranchingFlows"><a class="docs-heading-anchor" href="#BranchingFlows">BranchingFlows</a><a id="BranchingFlows-1"></a><a class="docs-heading-anchor-permalink" href="#BranchingFlows" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/MurrellGroup/BranchingFlows.jl">BranchingFlows</a>.</p><ul><li><a href="#BranchingFlows.BalancedSequential"><code>BranchingFlows.BalancedSequential</code></a></li><li><a href="#BranchingFlows.BranchingState"><code>BranchingFlows.BranchingState</code></a></li><li><a href="#BranchingFlows.CoalescencePolicy"><code>BranchingFlows.CoalescencePolicy</code></a></li><li><a href="#BranchingFlows.CoalescentFlow"><code>BranchingFlows.CoalescentFlow</code></a></li><li><a href="#BranchingFlows.SequentialCoalescencePolicy"><code>BranchingFlows.SequentialCoalescencePolicy</code></a></li><li><a href="#BranchingFlows.all_intragroup_pairs-Tuple{Any}"><code>BranchingFlows.all_intragroup_pairs</code></a></li><li><a href="#BranchingFlows.branching_bridge-Tuple{CoalescentFlow, Any, Any, Any}"><code>BranchingFlows.branching_bridge</code></a></li><li><a href="#BranchingFlows.canonical_anchor_merge-Tuple{Tuple{Vararg{Union{ForwardBackward.State, Flowfusion.Guide, Flowfusion.MaskedState}}}, Tuple{Vararg{Union{ForwardBackward.State, Flowfusion.Guide, Flowfusion.MaskedState}}}, Any, Any}"><code>BranchingFlows.canonical_anchor_merge</code></a></li><li><a href="#BranchingFlows.fixedcount_del_insertions-Tuple{BranchingState, Any}"><code>BranchingFlows.fixedcount_del_insertions</code></a></li><li><a href="#BranchingFlows.forest_bridge-Tuple{CoalescentFlow, Vararg{Any, 7}}"><code>BranchingFlows.forest_bridge</code></a></li><li><a href="#BranchingFlows.group_fixedcount_del_insertions-Tuple{BranchingState, Any}"><code>BranchingFlows.group_fixedcount_del_insertions</code></a></li><li><a href="#BranchingFlows.groupwise_max_coalescences-Tuple{Any}"><code>BranchingFlows.groupwise_max_coalescences</code></a></li><li><a href="#BranchingFlows.max_coalescences-Tuple{SequentialUniform, Any}"><code>BranchingFlows.max_coalescences</code></a></li><li><a href="#BranchingFlows.next_split_time-Union{Tuple{T}, Tuple{Any, Any, T}} where T"><code>BranchingFlows.next_split_time</code></a></li><li><a href="#BranchingFlows.sample_forest-Tuple{CoalescentFlow, AbstractVector}"><code>BranchingFlows.sample_forest</code></a></li><li><a href="#BranchingFlows.sample_split_times!-Union{Tuple{T}, Tuple{CoalescentFlow, BranchingFlows.FlowNode, T}} where T"><code>BranchingFlows.sample_split_times!</code></a></li><li><a href="#BranchingFlows.select_anchor_merge-NTuple{4, Any}"><code>BranchingFlows.select_anchor_merge</code></a></li><li><a href="#BranchingFlows.select_coalescence-Tuple{SequentialUniform, Any, Nothing}"><code>BranchingFlows.select_coalescence</code></a></li><li><a href="#BranchingFlows.sequential_pairs-Tuple{Any}"><code>BranchingFlows.sequential_pairs</code></a></li><li><a href="#BranchingFlows.should_append_on_split-Tuple{BranchingFlows.CoalescencePolicy}"><code>BranchingFlows.should_append_on_split</code></a></li><li><a href="#BranchingFlows.tree_bridge-Tuple{CoalescentFlow, Vararg{Any, 5}}"><code>BranchingFlows.tree_bridge</code></a></li><li><a href="#Flowfusion.regroup-Tuple{AbstractVector{&lt;:Tuple}}"><code>Flowfusion.regroup</code></a></li><li><a href="#Flowfusion.step-Tuple{CoalescentFlow, BranchingState, Tuple, Real, Real}"><code>Flowfusion.step</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BranchingFlows.BalancedSequential" href="#BranchingFlows.BalancedSequential"><code>BranchingFlows.BalancedSequential</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BalancedSequential(; alpha=1.0)</code></pre><p>Sequential policy that prefers coalescing smaller adjacent clusters first, encouraging balanced trees while respecting sequence adjacency. For an eligible adjacent pair <code>(i,i+1)</code>, the sampling weight is <code>(w_i + w_{i+1})^(-alpha)</code> where <code>w_k = nodes[k].weight</code>. Set <code>alpha=0</code> to recover uniform sequential selection; larger <code>alpha</code> increases preference for smaller clusters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/BranchingFlows.jl/blob/b150e2223dff9c861066fad4bf2786dcd9b23b61/src/merging.jl#L185-L193">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BranchingFlows.BranchingState" href="#BranchingFlows.BranchingState"><code>BranchingFlows.BranchingState</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BranchingState(state, groupings)</code></pre><p>Holds a batched state (or tuple of states) together with a matrix of group IDs (<code>groupings::AbstractMatrix{&lt;:Integer}</code>) with shape <code>(L, b)</code>, where <code>L</code> is the sequence length and <code>b</code> is batch size. Elements only coalesce/split within the same group.</p><p>Fields:</p><ul><li><code>state</code>: a <code>MaskedState</code> or a tuple of <code>MaskedState</code>s representing the element-wise process state(s) at the current time.</li><li><code>groupings::AbstractMatrix{&lt;:Integer}</code>: per-position group id.</li><li><code>del::AbstractMatrix{Bool}</code>: marks indices corresponding to to-be-deleted leaves in the conditional path.</li><li><code>ids::AbstractMatrix{Int}</code>: element ids for tracking; merged internal nodes produced during forest construction use id <code>0</code>.</li><li><code>branchmask::AbstractMatrix{Bool}</code>: where <code>true</code>, splits/deletions are permitted; where <code>false</code>, they are suppressed.</li><li><code>flowmask::AbstractMatrix{Bool}</code>: where <code>true</code>, the base process updates via <code>Flowfusion.step</code>; where <code>false</code>, state is held fixed.</li><li><code>padmask::AbstractMatrix{Bool}</code>: marks valid (unpadded) positions.</li></ul><p>Convenience constructor:     BranchingState(state, groupings; del=zeros(Bool,...), ids=1:size(groupings,1),                    branchmask=ones(Bool,...), flowmask=ones(Bool,...),                    padmask=ones(Bool,...))</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/BranchingFlows.jl/blob/b150e2223dff9c861066fad4bf2786dcd9b23b61/src/coalescent_flow.jl#L50-L76">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BranchingFlows.CoalescencePolicy" href="#BranchingFlows.CoalescencePolicy"><code>BranchingFlows.CoalescencePolicy</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Abstract supertype for all coalescence selection policies.</p><p>Implementors should provide:</p><ul><li><code>select_coalescence(policy, nodes) =&gt; Union{Nothing,Tuple{Int,Int}}</code></li><li><code>max_coalescences(policy, nodes) =&gt; Int</code></li></ul><p>Optional stateful hooks (no-ops by default):</p><ul><li><code>init!(policy, nodes)</code></li><li><code>update!(policy, nodes, i, j, new_index)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/BranchingFlows.jl/blob/b150e2223dff9c861066fad4bf2786dcd9b23b61/src/merging.jl#L3-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BranchingFlows.CoalescentFlow" href="#BranchingFlows.CoalescentFlow"><code>BranchingFlows.CoalescentFlow</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CoalescentFlow{Proc,D,F,Pol,Delp,Dh} &lt;: Process</code></pre><p>Branching/coalescent flow wrapper that composes an underlying Flowfusion process <code>P</code> with stochastic coalescence (backward) / splitting (forward) events, and optional deletions governed by a time-hazard distribution.</p><p>Fields:</p><ul><li><code>P::Proc</code>: underlying Flowfusion process (or tuple of processes) used for bridging between coalescence times.</li><li><code>branch_time_dist::D</code>: distribution on [0, 1] controlling split/coalescence event timing. Used both to sample absolute split times (for forests) and to scale small-step split Poisson rates via a truncated pdf at the current time.</li><li><code>split_transform::F</code>: elementwise map that converts model-predicted event logits into nonnegative intensities for split counts during forward-time simulation (default: <code>x -&gt; exp.(clamp.(x, -100, 11))</code>).</li><li><code>coalescence_policy::Pol</code>: policy controlling which elements coalesce at each event; see policies in <code>merging.jl</code>.</li><li><code>deletion_policy::Delp</code>: tag for deletion behavior (placeholder hook).</li><li><code>deletion_time_dist::Dh</code>: distribution on [0, 1] specifying the deletion hazard via its pdf/cdf; used exactly over intervals during conditional path sampling and via a small-step hazard approximation during <code>step</code>.</li></ul><p>Constructors:</p><ul><li><code>CoalescentFlow(P, branch_time_dist)</code> uses the default <code>split_transform</code>, <code>SequentialUniform()</code> policy, and <code>Uniform(0, 1)</code> deletion-time distribution.</li><li><code>CoalescentFlow(P, branch_time_dist, policy)</code> as above with a custom policy.</li><li><code>CoalescentFlow(P, branch_time_dist, policy, deletion_time_dist)</code> as above with a custom deletion-time distribution.</li></ul><p>Notes:</p><ul><li>Sequential policies assume sequence order is meaningful. Coalescences/splits are further constrained within groups (see <code>BranchingState.groupings</code>).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/BranchingFlows.jl/blob/b150e2223dff9c861066fad4bf2786dcd9b23b61/src/coalescent_flow.jl#L3-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BranchingFlows.SequentialCoalescencePolicy" href="#BranchingFlows.SequentialCoalescencePolicy"><code>BranchingFlows.SequentialCoalescencePolicy</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Coalescence policies merge sequentially adjacent elements, and thus depend on the sequential ordering of <code>nodes</code>.</p><p>Models using <code>SequentialCoalescencePolicy</code> may exploit sequence-order features (e.g., positional encodings). Caller must ensure ordering is meaningful. If the model does not have sequence-order features, then a <code>SequentialCoalescencePolicy</code> may still make sense if sequential order happens to relate to some other proximity property, otherwise it is just a weird kind of random coalescence.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/BranchingFlows.jl/blob/b150e2223dff9c861066fad4bf2786dcd9b23b61/src/merging.jl#L16-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BranchingFlows.all_intragroup_pairs-Tuple{Any}" href="#BranchingFlows.all_intragroup_pairs-Tuple{Any}"><code>BranchingFlows.all_intragroup_pairs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">all_intragroup_pairs(nodes)</code></pre><p>Iterator over all eligible intragroup pairs <code>(i, j)</code> with <code>i&lt;j</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/BranchingFlows.jl/blob/b150e2223dff9c861066fad4bf2786dcd9b23b61/src/merging.jl#L173-L177">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BranchingFlows.branching_bridge-Tuple{CoalescentFlow, Any, Any, Any}" href="#BranchingFlows.branching_bridge-Tuple{CoalescentFlow, Any, Any, Any}"><code>BranchingFlows.branching_bridge</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">branching_bridge(P::CoalescentFlow, X0sampler, X1s, times;
                 T=Float32, use_branching_time_prob=0, maxlen=Inf,
                 coalescence_factor=1.0, merger=canonical_anchor_merge,
                 coalescence_policy=P.coalescence_policy,
                 length_mins=nothing, deletion_pad=0, X1_modifier=identity)</code></pre><p>Vectorized conditional bridging over a batch. For each <code>(X1, t)</code> pair, samples an independent forest (respecting group minima and policy), runs <code>tree_bridge</code> for all roots and aggregates the outputs into batched tensors.</p><p>Arguments:</p><ul><li><code>times</code>: vector of times (length = batch size) or a <code>UnivariateDistribution</code> (a time is drawn per batch item).</li><li><code>length_mins</code>: per-group minima control for forest construction. May be: <code>nothing</code>, <code>Int</code>, <code>DiscreteUnivariateDistribution</code>, <code>Dict{Int,Int}</code>, <code>Dict{Int,&lt;:DiscreteUnivariateDistribution}</code>, or a vector of any of these (length equal to batch size).</li><li><code>deletion_pad</code>: if &gt; 0, pads each <code>X1</code> with additional to-be-deleted duplicates so that, in expectation, each group has <code>deletion_pad * max(len(x0_group), len(x1_group))</code> elements; implemented via per-group Poisson draws and <code>group_fixedcount_del_insertions</code>.</li><li><code>X1_modifier</code>: optional transform applied to each (possibly deletion-padded) <code>X1</code> prior to forest sampling (e.g., to enforce masking on deleted states).</li></ul><p>Returns a named tuple:</p><ul><li><code>t::Vector{T}</code>: the time used per batch item (possibly overridden by a split time).</li><li><code>Xt::BranchingState</code>: batched states at time <code>t</code>, with <code>state</code> as masked states (or tuple thereof) and bookkeeping masks/ids/groupings.</li><li><code>X1anchor</code>: masked anchor states batched in the same structure as <code>Xt.state</code>.</li><li><code>del::Matrix{Bool}</code>: deletion flags per element in <code>Xt</code>.</li><li><code>descendants::Matrix{Int}</code>: descendant counts (w) per element.</li><li><code>splits_target::Matrix{T}</code>: per-element training targets for split heads, computed as <code>max(descendants-1, 0)</code>.</li><li><code>prev_coalescence::Matrix{T}</code>: last coalescence time before each element.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/BranchingFlows.jl/blob/b150e2223dff9c861066fad4bf2786dcd9b23b61/src/coalescent_flow.jl#L576-L611">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BranchingFlows.canonical_anchor_merge-Tuple{Tuple{Vararg{Union{ForwardBackward.State, Flowfusion.Guide, Flowfusion.MaskedState}}}, Tuple{Vararg{Union{ForwardBackward.State, Flowfusion.Guide, Flowfusion.MaskedState}}}, Any, Any}" href="#BranchingFlows.canonical_anchor_merge-Tuple{Tuple{Vararg{Union{ForwardBackward.State, Flowfusion.Guide, Flowfusion.MaskedState}}}, Tuple{Vararg{Union{ForwardBackward.State, Flowfusion.Guide, Flowfusion.MaskedState}}}, Any, Any}"><code>BranchingFlows.canonical_anchor_merge</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">canonical_anchor_merge(S1, S2, w1, w2)</code></pre><p>Merge two anchor states <code>S1</code> and <code>S2</code> (each possibly a tuple of component states) into a single anchor representing their parent during tree coalescence.</p><p>Behavior by component:</p><ul><li>Tuple of states: applies <code>canonical_anchor_merge</code> elementwise with the same weights.</li><li><code>MaskedState</code>: unwraps and merges the underlying state.</li><li><code>ContinuousState</code>: weighted Euclidean average, <code>(w1*S1 + w2*S2)/(w1+w2)</code>.</li><li><code>ManifoldState</code>: geodesic interpolation via <code>ForwardBackward.interpolate(S1, S2, w2, w1)</code>.</li><li><code>DiscreteState</code>: sets the anchor to the mask/dummy token (assumes the dummy token is the last category <code>K</code>); both dense-int and onehot encodings are supported.</li></ul><p><code>w1</code> and <code>w2</code> are nonnegative weights, typically child descendant counts, used only by the continuous/manifold components; discrete components always resolve to the dummy token to avoid leaking label information through anchors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/BranchingFlows.jl/blob/b150e2223dff9c861066fad4bf2786dcd9b23b61/src/states.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BranchingFlows.fixedcount_del_insertions-Tuple{BranchingState, Any}" href="#BranchingFlows.fixedcount_del_insertions-Tuple{BranchingState, Any}"><code>BranchingFlows.fixedcount_del_insertions</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fixedcount_del_insertions(X1::BranchingState, num_events)</code></pre><p>Insert exactly <code>num_events</code> duplication events into <code>X1</code>, sampling targets uniformly with replacement from elements where <code>flowmask &amp; branchmask</code> are true. Each event inserts a duplicate either before or after the original (chosen uniformly at random). For each event, exactly one of the two involved indices (original or the newly inserted duplicate) is marked for deletion. If multiple events hit the same original, only one can mark the original as deleted; subsequent events allocate their deletion to their respective duplicates.</p><p>Returns a new <code>BranchingState</code> constructed analogously to <code>uniform_del_insertions</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/BranchingFlows.jl/blob/b150e2223dff9c861066fad4bf2786dcd9b23b61/src/coalescent_flow.jl#L138-L152">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BranchingFlows.forest_bridge-Tuple{CoalescentFlow, Vararg{Any, 7}}" href="#BranchingFlows.forest_bridge-Tuple{CoalescentFlow, Vararg{Any, 7}}"><code>BranchingFlows.forest_bridge</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">forest_bridge(P::CoalescentFlow, X0sampler, X1, t, groups, branchable, flowable, deleted;
              T=Float32, use_branching_time_prob=0, maxlen=Inf,
              coalescence_factor=1.0, merger=canonical_anchor_merge,
              coalescence_policy=P.coalescence_policy, group_mins=nothing)</code></pre><p>Run a single conditional bridge at time <code>t</code> for each root in a forest sampled from <code>X1</code> and <code>groups</code>. The forest is built with <code>sample_forest</code> using the provided <code>branchable</code>, <code>flowable</code>, and <code>deleted</code> flags. Returns a flat vector of segment tuples (see <code>tree_bridge</code>).</p><p>Arguments:</p><ul><li><code>X0sampler(root)</code>: a function that, given a forest root node, returns the initial state to bridge from.</li><li><code>use_branching_time_prob</code>: with this probability, override <code>t</code> with a random absolute split time drawn from the forest’s <code>coal_times</code>, exposing the model to states exactly at split points.</li><li><code>maxlen</code>: if the number of segments at/after <code>t</code> would exceed <code>maxlen</code>, this function resamples the forest to keep the total bounded.</li><li><code>group_mins</code>: forwarded through to <code>sample_forest</code> (see its docstring).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/BranchingFlows.jl/blob/b150e2223dff9c861066fad4bf2786dcd9b23b61/src/coalescent_flow.jl#L521-L541">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BranchingFlows.group_fixedcount_del_insertions-Tuple{BranchingState, Any}" href="#BranchingFlows.group_fixedcount_del_insertions-Tuple{BranchingState, Any}"><code>BranchingFlows.group_fixedcount_del_insertions</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">group_fixedcount_del_insertions(X1::BranchingState, group_num_events)</code></pre><p>Insert a fixed number of duplication events per group as specified by the dictionary <code>group_num_events</code>, which maps a group index (as found in <code>X1.groupings</code>) to the number of events for that group.</p><p>Behavior per event matches <code>fixedcount_del_insertions</code>:</p><ul><li>Target indices are sampled uniformly with replacement among elements where <code>flowmask &amp; branchmask</code> are true and whose group equals the requested group.</li><li>Each event inserts a duplicate either before or after the original (chosen uniformly at random).</li><li>For each event, exactly one of the two involved indices (original or newly inserted duplicate) is marked for deletion. If multiple events hit the same original, only one can mark the original as deleted; subsequent events allocate their deletion to their respective duplicates.</li></ul><p>Returns a new <code>BranchingState</code> constructed analogously to <code>uniform_del_insertions</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/BranchingFlows.jl/blob/b150e2223dff9c861066fad4bf2786dcd9b23b61/src/coalescent_flow.jl#L223-L242">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BranchingFlows.groupwise_max_coalescences-Tuple{Any}" href="#BranchingFlows.groupwise_max_coalescences-Tuple{Any}"><code>BranchingFlows.groupwise_max_coalescences</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Compute an upper bound on the number of coalescences possible under branchable merging within groups. Used as a default for non-sequential policies.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/BranchingFlows.jl/blob/b150e2223dff9c861066fad4bf2786dcd9b23b61/src/merging.jl#L46-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BranchingFlows.max_coalescences-Tuple{SequentialUniform, Any}" href="#BranchingFlows.max_coalescences-Tuple{SequentialUniform, Any}"><code>BranchingFlows.max_coalescences</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">max_coalescences(::SequentialUniform, nodes)</code></pre><p>Count the number of eligible sequentially-adjacent pairs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/BranchingFlows.jl/blob/b150e2223dff9c861066fad4bf2786dcd9b23b61/src/merging.jl#L152-L156">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BranchingFlows.next_split_time-Union{Tuple{T}, Tuple{Any, Any, T}} where T" href="#BranchingFlows.next_split_time-Union{Tuple{T}, Tuple{Any, Any, T}} where T"><code>BranchingFlows.next_split_time</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Absolute time of the next split on this lineage.</p><p>H  : distribution for F_H on [0,1] with <code>cdf</code> and <code>quantile</code> W  : descendant count at the next node, m = W - 1 must be ≥ 1 t0 : current absolute time in [0,1)</p><p>Implements: draw E ~ Exp(1), set S* = (1 - cdf(H,t0)) * exp(-E/m), return quantile(H, 1 - S*).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/BranchingFlows.jl/blob/b150e2223dff9c861066fad4bf2786dcd9b23b61/src/coalescent_flow.jl#L343-L352">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BranchingFlows.sample_forest-Tuple{CoalescentFlow, AbstractVector}" href="#BranchingFlows.sample_forest-Tuple{CoalescentFlow, AbstractVector}"><code>BranchingFlows.sample_forest</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sample_forest(P::CoalescentFlow, elements;
              groupings=zeros(Int, length(elements)),
              branchable=ones(Bool, length(elements)),
              flowable=ones(Bool, length(elements)),
              deleted=zeros(Bool, length(elements)),
              ids=1:length(elements),
              T=Float32,
              coalescence_factor=1.0,
              merger=canonical_anchor_merge,
              coalescence_policy=P.coalescence_policy,
              group_mins=nothing)</code></pre><p>Sample a coalescent forest over <code>elements</code> with per-element <code>groupings</code> and boolean <code>branchable</code> flags. Returns <code>(forest_nodes, coal_times)</code> where <code>forest_nodes</code> is a vector of <code>FlowNode</code> roots (one per surviving group block), and <code>coal_times</code> is a vector of absolute split times sampled across the forest (not sorted).</p><p>Arguments:</p><ul><li><code>flowable</code>: marks elements whose state should be bridged (non-flowables are emitted as fixed segments during conditional path sampling).</li><li><code>deleted</code>: marks which leaves correspond to to-be-deleted elements at t=1.</li><li><code>ids</code>: element ids to carry through the forest (merged internal nodes get id <code>0</code>; merged nodes are always flowable and never deleted).</li><li><code>coalescence_factor</code>: Binomial parameter scaling the maximum possible number of coalescences computed by the policy. May be a numeric in [0,1] or a <code>UnivariateDistribution</code> (sampled once per call). <code>1.0</code> collapses each group to one root; <code>0.0</code> yields no coalescences.</li><li><code>merger</code>: function <code>merger(left_state, right_state, w_left, w_right)</code> used to build anchor states for internal nodes; see <code>canonical_anchor_merge</code> and <code>select_anchor_merge</code>.</li><li><code>coalescence_policy</code>: chooses which pair to coalesce at each event; see <code>merging.jl</code> for available policies and their semantics.</li><li><code>group_mins</code>: forwarded to <code>select_coalescence</code>. Supported forms depend on the active policy. For <code>SequentialUniform</code>, supported values are: <code>nothing</code> (no per-group minimum), <code>Dict{Int,Int}</code> (fixed per-group minima), or <code>Int</code> (uniform minimum for contiguous branchable blocks per group).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/BranchingFlows.jl/blob/b150e2223dff9c861066fad4bf2786dcd9b23b61/src/coalescent_flow.jl#L391-L429">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BranchingFlows.sample_split_times!-Union{Tuple{T}, Tuple{CoalescentFlow, BranchingFlows.FlowNode, T}} where T" href="#BranchingFlows.sample_split_times!-Union{Tuple{T}, Tuple{CoalescentFlow, BranchingFlows.FlowNode, T}} where T"><code>BranchingFlows.sample_split_times!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sample_split_times!(P::CoalescentFlow, node::FlowNode, t0; collection=nothing)</code></pre><p>Assign absolute split times to all internal nodes in the subtree rooted at <code>node</code> using <code>next_split_time(P.branch_time_dist, node.weight, t0)</code> whenever <code>node.weight &gt; 1</code>. Recurses into children with the newly assigned time as the lower bound.</p><p>If <code>collection</code> is provided (a vector), pushes each sampled absolute time into it. The collected times are not sorted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/BranchingFlows.jl/blob/b150e2223dff9c861066fad4bf2786dcd9b23b61/src/coalescent_flow.jl#L366-L376">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BranchingFlows.select_anchor_merge-NTuple{4, Any}" href="#BranchingFlows.select_anchor_merge-NTuple{4, Any}"><code>BranchingFlows.select_anchor_merge</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">select_anchor_merge(S1, S2, w1, w2)</code></pre><p>Stochastic alternative to <code>canonical_anchor_merge</code> that selects one of the two children as the parent anchor without interpolation. Chooses <code>S1</code> with probability <code>w1/(w1+w2)</code> and <code>S2</code> otherwise, then calls <code>canonical_anchor_merge</code> with weights <code>(1,0)</code> or <code>(0,1)</code> to preserve type-specific behavior (e.g., discrete masking).</p><p>Intended for scenarios where copying a child is preferable to averaging (e.g., to keep anchors on-manifold for complex discrete/structured components).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/BranchingFlows.jl/blob/b150e2223dff9c861066fad4bf2786dcd9b23b61/src/states.jl#L39-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BranchingFlows.select_coalescence-Tuple{SequentialUniform, Any, Nothing}" href="#BranchingFlows.select_coalescence-Tuple{SequentialUniform, Any, Nothing}"><code>BranchingFlows.select_coalescence</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">select_coalescence(::SequentialUniform, nodes)</code></pre><p>Uniformly choose one sequentially-adjacent branchable pair <code>(i, i+1)</code> within the same group. Returns <code>nothing</code> if no such pair exists.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/BranchingFlows.jl/blob/b150e2223dff9c861066fad4bf2786dcd9b23b61/src/merging.jl#L75-L80">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BranchingFlows.sequential_pairs-Tuple{Any}" href="#BranchingFlows.sequential_pairs-Tuple{Any}"><code>BranchingFlows.sequential_pairs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sequential_pairs(nodes)</code></pre><p>Iterator over all sequentially-adjacent eligible pairs <code>(i, i+1)</code> within groups.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/BranchingFlows.jl/blob/b150e2223dff9c861066fad4bf2786dcd9b23b61/src/merging.jl#L165-L169">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BranchingFlows.should_append_on_split-Tuple{BranchingFlows.CoalescencePolicy}" href="#BranchingFlows.should_append_on_split-Tuple{BranchingFlows.CoalescencePolicy}"><code>BranchingFlows.should_append_on_split</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">should_append_on_split(policy::CoalescencePolicy) -&gt; Bool</code></pre><p>Indicates whether forward-time split insertions should be appended to the end of the sequence (<code>true</code>), or inserted adjacently at the split location (<code>false</code>). Defaults to <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/BranchingFlows.jl/blob/b150e2223dff9c861066fad4bf2786dcd9b23b61/src/merging.jl#L37-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BranchingFlows.tree_bridge-Tuple{CoalescentFlow, Vararg{Any, 5}}" href="#BranchingFlows.tree_bridge-Tuple{CoalescentFlow, Vararg{Any, 5}}"><code>BranchingFlows.tree_bridge</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tree_bridge(P::CoalescentFlow, node, Xs, target_t, current_t, collection)</code></pre><p>Recursively traverse a <code>FlowNode</code> tree, running the underlying bridge <code>bridge(P.P, Xs, node.node_data, current_t, next_t)</code> either up to <code>target_t</code> or the node’s own split time. For each branch that crosses <code>target_t</code>, appends to <code>collection</code> a named tuple with fields:</p><ul><li><code>Xt</code>: the bridged state at <code>target_t</code> (or the node’s anchor if non-flowable),</li><li><code>t</code>: the evaluation time used for this segment,</li><li><code>X1anchor</code>: the anchor (node_data) ahead of the segment,</li><li><code>descendants</code>: the node’s descendant count (weight),</li><li><code>del</code>: whether this branch terminates in deletion at t=1,</li><li><code>branchable</code>: whether splits are permitted on this segment,</li><li><code>flowable</code>: whether the base process should evolve this segment,</li><li><code>group</code>: group id,</li><li><code>last_coalescence</code>: the most recent coalescence/split time behind the segment (open interval start),</li><li><code>id</code>: element id carried from the leaf; internal nodes use <code>0</code>.</li></ul><p>Deletion handling:</p><ul><li>During conditional path sampling, deletions use the exact survival ratio over <code>[current_t, target_t]</code> induced by <code>P.deletion_time_dist</code> (i.e., survival S(t)/S(current<em>t)), removing segments that fail to survive to `target</em>t`.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/BranchingFlows.jl/blob/b150e2223dff9c861066fad4bf2786dcd9b23b61/src/coalescent_flow.jl#L473-L496">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Flowfusion.regroup-Tuple{AbstractVector{&lt;:Tuple}}" href="#Flowfusion.regroup-Tuple{AbstractVector{&lt;:Tuple}}"><code>Flowfusion.regroup</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Flowfusion.regroup(elarray::AbstractVector{&lt;:Tuple})</code></pre><p>Utility to batch a vector of element-wise tuples of states into a tuple of batched states. Given <code>elarray::Vector{Tuple{S₁, S₂, …, Sₖ}}</code> of length <code>L</code>, returns <code>Tuple{Ŝ₁, Ŝ₂, …, Ŝₖ}</code> where each <code>Ŝᵢ</code> has length <code>L</code> (stacking the elements along the sequence dimension).</p><p>This specialization enables:</p><pre><code class="language-julia hljs">MaskedState.(regroup(elements), (flowmask,), (padmask,))</code></pre><p>when building <code>BranchingState</code> batches from per-segment bridges.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/BranchingFlows.jl/blob/b150e2223dff9c861066fad4bf2786dcd9b23b61/src/states.jl#L59-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Flowfusion.step-Tuple{CoalescentFlow, BranchingState, Tuple, Real, Real}" href="#Flowfusion.step-Tuple{CoalescentFlow, BranchingState, Tuple, Real, Real}"><code>Flowfusion.step</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Flowfusion.step(P::CoalescentFlow, XₜBS::BranchingState, hat::Tuple, s₁::Real, s₂::Real)</code></pre><p>Advance the process forward in time from <code>s₁</code> to <code>s₂</code> for a single-batch <code>BranchingState</code>, allowing split events. The underlying continuous/discrete states are advanced via <code>Flowfusion.step(P.P, ...)</code>, and split counts are drawn from a Poisson law parameterized by the transformed event intensities and a factor of the truncated branch-time density at <code>s₁</code>.</p><p>Deletion handling:</p><ul><li>Uses a small-step hazard approximation induced by <code>P.deletion_time_dist</code>.</li><li>Let <code>h(s₁) = f(s₁) / S(s₁)</code> where <code>f</code>/<code>S</code> are the pdf/survival. The base small-step probability is <code>1 - exp(-h(s₁) * Δt)</code>, scaled by <code>ρ = sigmoid(del_logits)</code> from the model head. Deletions are suppressed where <code>branchmask</code> is <code>false</code>.</li></ul><p>Split handling:</p><ul><li>Per-position split counts are sampled from <code>Poisson(Δt * split_transform(λ) * pdf(Truncated(branch_time_dist, s₁, 1), s₁))</code>, masked by <code>branchmask</code>.</li><li>If a discrete component changes its token at an index between <code>s₁</code> and <code>s₂</code>, splits at that index are suppressed for this step to avoid simultaneous discrete changes and splits.</li><li>New elements are inserted adjacently after the split location (no append mode).</li></ul><p>Returns a new single-batch <code>BranchingState</code> where:</p><ul><li><code>state</code> holds the updated masked states,</li><li><code>groupings</code>, <code>flowmask</code>, <code>branchmask</code> are updated to reflect splits/deletions,</li><li>default <code>ids</code>, <code>padmask</code>, and <code>del</code> are constructed consistently with shapes.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/BranchingFlows.jl/blob/b150e2223dff9c861066fad4bf2786dcd9b23b61/src/coalescent_flow.jl#L688-L716">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.15.0 on <span class="colophon-date" title="Tuesday 11 November 2025 21:48">Tuesday 11 November 2025</span>. Using Julia version 1.12.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
